DETECTING ATTACKS BY MATCHING OF ACCESS FREQUENCIES AND SEQUENCES IN DIFFERENT SOFTWARE LAYERS
A number of events are counted in different layers of a computing environment during execution of a software application. The number of counted events can be compared to a previously generated cluster set to determine that at least one of the counted events is an outlier. Data can then be provided that characterizes the at least one of the counted events determined to be an outlier. In some cases, some or all of the functionality of the software application can be selectively disabled. Related apparatus, systems, techniques and articles are also described.
End-to-End Taint Tracking for Detection and Mitigation of Injection Vulnerabilities in Web Applications
The embodiments described in this disclosure may be adapted to detect and mitigate tainted content in network communications across client-server boundaries using a pair of complementary taint engines at both ends of the network. Methods, systems and computer readable storage media are adapted to receive request from a web application of a client system and generate standard responses. The header of the request can include a request taint value that can be evaluated to determine whether the request is a standard network transfer protocol request (e.g., HTTP request) or a multipart network transfer protocol request (e.g., a CTTP request). If the request is a multipart network transfer protocol request, a multipart network transfer protocol response can be constructing based on the generated standard network transfer protocol response, and client systems can be configured to detect tainted content based on the multipart network transfer protocol response.
Cooperative static and dynamic analysis of web application code for finding security vulnerabilities
Implementations of the present disclosure include methods, systems, and computer-readable storage media for receiving, by a SSCA module of a server, source code data based on one or more web pages of a website, analyzing, by the SSCA module, the source code data using static analysis to provide initial results, the initial results including identifiers respectively assigned to one or more variables provided in the source code data, transmitting, by the SSCA module, a request to the website through a proxy server, the request being based on the initial results, the proxy server receiving a response and transmitting a rewritten response to a DSCA module executed on a client, receiving, by the SSCA module, updated source code data from the DSCA module, the updated source code data being provided based on the rewritten response, and updating, by the SSCA module, the initial results based on the updated source code data.
Code-Reuse Attacks for the Web: Breaking Cross-Site Scripting Mitigations via Script Gadgets
Cross-Site Scripting (XSS) is an unremitting problem for the Web. Since its initial public documentation in 2000 until now, XSS has been continuously on top of the vulnerability statistics. Even though there has been a considerable amount of research and developer education to address XSS on the source code level, the overall number of discovered XSS problems remains high. Because of this, various approaches to mitigate XSS have been proposed as a second line of defense, with HTML sanitizers, Web Application Firewalls, browser-based XSS filters, and the Content Security Policy being some prominent examples. Most of these mechanisms focus on script tags and event handlers, either by removing them from user-provided content or by preventing their script code from executing. In this paper, we demonstrate that this approach is no longer sufficient for modern applications: We describe a novel Web attack that can circumvent all of theses currently existing XSS mitigation techniques. In this attack, the attacker abuses so called script gadgets (legitimate JavaScript fragments within an application's legitimate code base) to execute JavaScript. In most cases, these gadgets utilize DOM selectors to interact with elements in the Web document. Through an initial injection point, the attacker can inject benign-looking HTML elements which are ignored by these mitigation techniques but match the selector of the gadget. This way, the attacker can hijack the input of a gadget and cause processing of his input, which in turn leads to code execution of attacker-controlled values. We demonstrate that these gadgets are omnipresent in almost all modern JavaScript frameworks and present an empirical study showing the prevalence of script gadgets in productive code. As a result, we assume most mitigation techniques in web applications written today can be bypassed.
Deemon: Detecting CSRF with Dynamic Analysis and Property Graphs
Cross-Site Request Forgery (CSRF) vulnerabilities are a severe class of web vulnerabilities that have received only marginal attention from the research and security testing communities. While much effort has been spent on countermeasures and detection of XSS and SQLi, to date, the detection of CSRF vulnerabilities is still performed predominantly manually. In this paper, we present Deemon, to the best of our knowledge the first automated security testing framework to discover CSRF vulnerabilities. Our approach is based on a new modeling paradigm which captures multiple aspects of web applications, including execution traces, data flows, and architecture tiers in a unified, comprehensive property graph. We present the paradigm and show how a concrete model can be built automatically using dynamic traces.Then, using graph traversals, we mine for potentially vulnerable operations. Using the information captured in the model, our approach then automatically creates and conducts security tests, to practically validate the found CSRF issues. We evaluate the effectiveness of Deemon with 10 popular open source web applications. Our experiments uncovered 14 previously unknown CSRF vulnerabilities that can be exploited, for instance, to take over user accounts or entire websites.
How the Web Tangled Itself: Uncovering the History of Client-Side Web (In) Security
While in its early days, the Web was mostly static, it has organically grown into a full-fledged technology stack. This evolution has not followed a security blueprint, resulting in many classes of vulnerabilities specific to the Web. Even though the server-side code of the past has long since vanished, the Internet Archive gives us a unique view on the historical development of the Web’s client side and its (in)security. Uncovering the insights which fueled this development bears the potential to not only gain a historical perspective on client-side Web security, but also to outline better practices going forward. To that end, we examined the code and header information of the most important Web sites for each year between 1997 and 2016, amounting to 659,710 different analyzed Web documents. From the archived data, we first identify key trends in the technology deployed on the client, such as the increasing complexity of clientside Web code and the constant rise of multi-origin application scenarios. Based on these findings, we then assess the advent of corresponding vulnerability classes, investigate their prevalence over time, and analyze the security mechanisms developed and deployed to mitigate them. Correlating these results allows us to draw a set of overarching conclusions: Along with the dawn of JavaScript-driven applications in the early years of the millennium, the likelihood of client-side injection vulnerabilities has risen. Furthermore, there is a noticeable gap in adoption speed between easy-to-deploy security headers and more involved measures such as CSP. But there is also no evidence that the usage of the easy-todeploy techniques reflects on other security areas. On the contrary, our data shows for instance that sites that use HTTPonly cookies are actually more likely to have a Cross-Site Scripting problem. Finally, we observe that the rising security awareness and introduction of dedicated security technologies had no immediate impact on the overall security of the client-side Web.
Client-Side XSS in Theorie und Praxis
Although known for more than a decade [1], the vulnerability class of client-side cross-site scripting is still treated as the stepchild of the injection vulnerability family. Always in the shadow of big siblings, such as SQL injection or server-side XSS, they are often overlooked and received little attention in the past. In this paper, we'll explore the subject and examine not only how often such insecurities are found in real web pages, but also what causes the underlying vulnerability and how it can be easily prevented.
Transparent Namespace-Aware Mechanism for Encrypted Storage of Data within Web Applications
Implementations of the present disclosure include methods, systems, and computer-readable storage mediums for providing data security in web applications operating offline, and actions include receiving a request from a user of a web application during offline use of the web application in a web browser, the request implicating a data item, receiving an offline password from the user, decrypting an encrypted offline key to provide an offline key, and selectively using the offline key to process the data item based on a data protection policy stored in storage of the web browser and a protection level assigned to the data item.
POSTER: mapping the landscape of large-scale vulnerability notifications
The Internet is an ever-growing ecosystem with diverse software and hardware applications deployed in numerous countries around the globe. This heterogenous structure, however, is reduced to a homogenous means of addressing servers, i.e., their IP address. Due to this, analyzing different Internet services for vulnerabilities at scale is easy, leading to many researcher focusing on large-scale detection of many types of flaws. On the other hand, the persons responsible for the administration of said services are as heterogenous as the Internet architecture itself: be it in spoken languages or knowledge of technical details of the services. The notification of vulnerable services has long been treated as a side note in research. Recently, the community has focussed more not only the detection of flaws, but also on the notification of affected parties. These works, however, only analyze a small segment of the problem space. Hence, in this paper, we investigate the issues encountered by the previous works and provide a number of future directions for research, ultimately aiming to allow for an easier means of notifying affected parties about vulnerabilities at scale.
Web page integrity validation
An aspect identifier of an integrity validation script may be provided to a browser application, that, during execution thereof by the browser application when rendering a page, identifies a document object model (DOM) aspect of a DOM of the page. A copy generator of the integrity validation script may be provided to the browser application that, during execution thereof by the browser application when rendering the page, generates a copy of the identified DOM aspect. The integrity validation script is configured to test an integrity of the DOM based on attempted deletion of the identified DOM aspect, while maintaining the identified DOM aspect through the copy thereof.
Hey, You Have a Problem: On the Feasibility of Large-Scale Web Vulnerability Notification.
Large-scale discovery of thousands of vulnerable Web sites has become a frequent event, thanks to recent advances in security research and the rise in maturity of Internet-wide scanning tools. The issues related to disclosing the vulnerability information to the affected parties, however, have only been treated as a side note in prior research. In this paper, we systematically examine the feasibility and efficacy of large-scale notification campaigns. For this, we comprehensively survey existing communication channels and evaluate their usability in an automated notification process. Using a data set of over 44,000 vulnerable Web sites, we measure success rates, both with respect to the total number of fixed vulnerabilities and to reaching responsible parties, with the following highlevel results: Although our campaign had a statistically significant impact compared to a control group, the increase in the fix rate of notified domains is marginal. If a notification report is read by the owner of the vulnerable application, the likelihood of a subsequent resolution of the issues is sufficiently high: about 40%. But, out of 35,832 transmitted vulnerability reports, only 2,064 (5.8%) were actually received successfully, resulting in an unsatisfactory overall fix rate, leaving 74.5% of Web applications exploitable after our month-long experiment. Thus, we conclude that currently no reliable notification channels exist, which significantly inhibits the success and impact of large-scale notification.
Ensuring endpoint authenticity in WebRTC peer-to-peer communication
WebRTC is one of the latest additions to the ever growing repository of Web browser technologies, which push the envelope of native Web application capabilities. WebRTC allows real-time peer-to-peer audio and video chat, that runs purely in the browser. Unlike existing video chat solutions, such as Skype, that operate in a closed identity ecosystem, WebRTC was designed to be highly flexible, especially in the domains of signaling and identity federation. This flexibility, however, opens avenues for identity fraud. In this paper, we explore the technical underpinnings of WebRTC's identity management architecture. Based on this analysis, we identify three novel attacks against endpoint authenticity. To answer the identified threats, we propose and discuss defensive strategies, including security improvements for the WebRTC specifications and mitigation techniques for the identity and service providers.
Managing access to secured content
Techniques for preventing unauthorized access to protected network resources include accessing, from a client appliance connected in a distributed network, a computing appliance through the world wide web, the computing appliance including a DNS server addressed by a particular domain name; receiving, from the computing appliance, a portion of code at the client appliance through a web browser of the client appliance, receiving, to a server appliance connected in the distributed network, a request to access secure content stored on the server appliance by the portion of code; comparing the domain name of the DNS server with a server-origin of the secure content; and based on the domain name of the DNS server being exclusive of a set of server-origin values that includes the server-origin, denying access to the request.
Condition checking for page integration of third party services
A widget generator may be configured to provide, to a browser application, a widget that is executable to be rendered in conjunction with a page rendered by the browser application. A protection manager may be configured to provide, to the browser application and in conjunction with the widget, a protection script that is executable within a page context of the page and separate from a widget context of the widget. The protection script, during execution, validates a condition associated with a frame of the page that is used to render the widget, and enables functionality of the widget within the page, based on validation of the condition.
Safe script templating to provide reliable protection against attacks
Methods, systems, and computer-readable storage media for inhibiting cross-site scripting (XSS) attacks, where actions include receiving a computer-readable document that provides a content security policy (CSP) for a website and an extension to the CSP, the CSP specifying allowed script checksums, each allowed script checksum being associated with a script that is allowed to be executed, the extension requiring comparison of script checksums before respective scripts can be executed, receiving script templates and a value list, calculating an expected script checksum for each script template to provide respective expected script checksums, comparing the expected script checksums to the allowed script checksums, and determining that at least one expected script checksum matches an allowed script checksum, and in response, executing a respective script that corresponds to the at least one expected script checksum.
Security testing: A survey
Identifying vulnerabilities and ensuring security functionality by security testing is a widely applied measure to evaluate and improve the security of software. Due to the openness of modern software-based systems, applying appropriate security testing techniques is of growing importance and essential to perform effective and efficient security testing. Therefore, an overview of actual security testing techniques is of high value both for researchers to evaluate and refine the techniques and for practitioners to apply and disseminate them. This chapter fulfills this need and provides an overview of recent security testing techniques. For this purpose, it first summarize the required background of testing and security engineering. Then, basics and recent developments of security testing techniques applied during the secure software development life cycle, ie, model-based security testing, code-based testing and static analysis, penetration testing and dynamic analysis, as well as security regression testing are discussed. Finally, the security testing techniques are illustrated by adopting them for an example three-tiered web-based business application.
From facepalm to brain bender: Exploring client-side cross-site scripting
Although studies have shown that at least one in ten Web pages contains a client-side XSS vulnerability, the prevalent causes for this class of Cross-Site Scripting have not been studied in depth. Therefore, in this paper, we present a large-scale study to gain insight into these causes. To this end, we analyze a set of 1,273 real-world vulnerabilities contained on the Alexa Top 10k domains using a specifically designed architecture, consisting of an infrastructure which allows us to persist and replay vulnerabilities to ensure a sound analysis. In combination with a taint-aware browsing engine, we can therefore collect important execution trace information for all flaws. Based on the observable characteristics of the vulnerable JavaScript, we derive a set of metrics to measure the complexity of each flaw. We subsequently classify all vulnerabilities in our data set accordingly to enable a more systematic analysis. In doing so, we find that although a large portion of all vulnerabilities have a low complexity rating, several incur a significant level of complexity and are repeatedly caused by vulnerable third-party scripts. In addition, we gain insights into other factors related to the existence of client-side XSS flaws, such as missing knowledge of browser-provided APIs, and find that the root causes for Client-Side Cross-Site Scripting range from unaware developers to incompatible first- and third-party code.
European Web Security Roadmap
In this document, we thoroughly assess the current state of web application security in respect to state-of-the-practice, state-of-the-art, research, and standardisation with special attention to the European aspect. The collected data is then utilized to successively define a near to mid-term research roadmap for Web security to guide impactful research and development of secure and trustworthy Web technologies. In this context the deliverable collects areas of Web security which are still underdeveloped, identifies missing pieces in the research landscape, and points out promising directions for future research. In addition connections between research and standardisation activities are explored, as well as existing mismatches in the area are shown. This way, the deliverable provides a bigger picture on the field of Web security research, to aid the decision making process, when it comes to create new research/standardisation actives and future research projects/work programs. To structure this ambitious project, Part I first defines a systematic methodology for data collection and analysis. This methodology is based on five well defined objectives which were directly derived from the STREWS mission statement: (OBJ.1) Identify significant gaps between the state-of-the-practice and current research results. (OBJ.2) Identify mismatches in between ongoing/future standardisation and research activities in the field of Web security and the needs of the Web’s practitioners. (OBJ.3) Identify the emerging topics and future hot spots of Web security. (OBJ.4) Map standardization and research efforts to the observed emerging topics in Web security. Identify topics that require further attention or are not covered yet. (OBJ.5) Obtain current information on the state of European research in the field of Web security. Guided by these objectives, suitable data sources were identified, which in total span the full spectrum of web application security. These data sources were chosen according to their capability to cover the four STREWS focus areas (state-of-the-practice, research and innovation, standardisation activities, and emerging topics). For each of the chosen data sources a clear data collection and analysis process was determined, to ensure that the resulting outcome helps to achieve the deliverable’s objectives. After the selection process a total of ten distinct data sources were selected to appear in this document: (DS.1) The State-of-the-Practice in today’s Web Software (DS.2) Selected Empirical Studies (DS.3) Observable Gaps between the State-of-the-Art and the State-of-the-Practice (DS.4) Interactive Survey (DS.5) Review of related NoE and Policy activities (DS.6) STREWS Workshops (DS.7) Standardisation Activities (DS.8) STREWS Case Study 1: WebRTC (DS.9) STREWS Case Study 2: Web Security Architectures (DS.10) Cybersecurity Each of these distinct topics is explored in depth in Part II of the deliverable. The sum of the collected reports provides a comprehensive overview on the current state of web application security and web application security research. In the second half of Part I, the collected data is analysed according to the goals of the deliverable. For this, we first draw individual conclusions from the distinct data sources. Then, in a second step, these results are correlated on an objective level. In this step, we identify and explore the emerging and hot topics in web security that require future attention from research, practice and standardisation, namely: client-side complexity, JavaScript sandboxing, server-driven security policies, JavaScript crypto and hardware tokens, the end of the clientserver paradigm, web privacy, and advancing web authentication and session tracking. Finally, we use the collected insight to pinpoint the upcoming security research challenges for the European web, which either directly result from the emerging topics or materialized as notable insights from the objective-level data correlation: • Challenge 1: Revisiting classic attacks • Challenge 2: Handling the extending web paradigm • Challenge 3: Realizing real end-to-end security • Challenge 4: Increasing End-user Security and Privacy The combination of the identified emerging topics and the overarching research challenges results in an exiting and promising research roadmap for the mid to long term. We expect, that following this roadmap will lead to impactful results, which address the future security problems of the Web, while being well suited to be adopted by practitioners and standardisation.
Trusted user interface for mobile web applications
Implementations of the present disclosure include methods, systems, and computer-readable storage mediums for user confirmation of actions to be performed by a web application hosted on one or more servers. Actions can include receiving user input indicating a request directed to the web application, the user input being received through a mobile web browser, determining that the user input is requesting execution of an authorized action, and in response, providing data associated with the request for processing by a mobile authenticator application, providing a user interface generated by the mobile authenticator application based on the data, and receiving user confirmation of the authorized action through the user interface, and in response: providing a signed response by the mobile authenticator application, and transmitting the signed response to the one or more servers to initiate execution of the authorized action.
The Unexpected Dangers of Dynamic JavaScript.
Modern Web sites frequently generate JavaScript on-thefly via server-side scripting, incorporating personalized user data in the process. In general, cross-domain access to such sensitive resources is prevented by the SameOrigin Policy. The inclusion of remote scripts via the HTML script tag, however, is exempt from this policy. This exemption allows an adversary to import and execute dynamically generated scripts while a user visits an attacker-controlled Web site. By observing the execution behavior and the side effects the inclusion of the dynamic script causes, the attacker is able to leak private user data leading to severe consequences ranging from privacy violations up to full compromise of user accounts. Although this issues has been known for several years under the term Cross-Site Script Inclusion, it has not been analyzed in-depth on the Web. Therefore, to systematically investigate the issue, we conduct a study on its prevalence in a set of 150 top-ranked domains. We observe that a third of the surveyed sites utilize dynamic JavaScript. After evaluating the effectiveness of the deployed countermeasures, we show that more than 80% of the sites are susceptible to attacks via remote script inclusion. Given the results of our study, we provide a secure and functionally equivalent alternative to the use of dynamic scripts.
LogSec: adaptive protection for the wild wild web
Today, a Web browser is a user's gateway to a multitude of Web applications, each with its own balance between confidentiality and integrity versus cross-application content sharing. Modern Web browsers apply the same permissive security policy to all content regardless of its demand for security -- a behavior that enables attacks such as cross-site request forgery (CSRF) or sidejacking. To defend against such attacks, existing countermeasures enforce overly strict policies, which expose incompatibilities with real-world Web applications. As a consequence, users get annoyed by malfunctions. In this paper, we show how browser behavior can be adapted based on the user's authentication status. The browser can enforce enhanced security policies, if necessary, and permit modern communication features, if possible. Our approach mitigates CSRF, session hijacking, sidejacking, and session fixation attacks. We present the implementation as a browser extension, named LogSec, that passively detects the user's authentication status without server-side support and is transparent for the user.
Case study 2 Report: Secure Web Architectures
For the Web, security was for a long time an issue that was devoted to the underlying network layer. The declarative approach of the Web of documents used HTML4 and CSS and did not offer a very high attacking surface. With the movement of the Web towards being the Open Web Platform for Applications, this has changed. More and more vital applications in the area of government, economy and social life use the web as their platform of choice. And those higher value applications and services made it much more interesting for attackers to spend time finding loopholes on the Open Web Platform. Additionally, the Community needed to respond to the attack against the Internet via Pervasive Monitoring and the challenges laid down in RFC7258[77]. The Community reacted to those challenges with a variety of improvements and tools that web application developers can use to increase security, confidentiality and privacy for work. This includes improvements in the protocol sector, the widespread use of encryption and a number of tools to address the vulnerabilities created by the new functionality introduced by the Open Web Platform. Some of those security tools are still in their infancy, but look promising. Some tools need support to take off. Some have the potential to have landscape changing effects by tying the trust chain to new actors. After the systematic evaluation of the Web Security landscape by the Web-platform Security Guide[59], this document describes the toolbox now available at a rather high level and picks the three main topics where STREWS is able to provide high impact advances for Web security to the Community. Secure Web Architectures thus suggests to further the compartimentalisation and modularisation of web applications by allowing developers to sandbox certain modules. While the Community has already thought about it very recently, STREWS comes with a well thoughtout proposal that may allow the Community to advance more quickly. Another area of active research with potential high impact is the question on how to secure sessions on the Web. Session management is a crucial component in every modern web application. It links subsequent requests together, enabling a rich and interactive user experience. But sessions can be hijacked with potentially high damages. STREWS makes suggestions on how to further improve sessions by suggesting the SecSess approach that effectively prevents the unauthorized transfer of an established session, by eradicating the bearer token properties of the session identifier. Finally, Cross-site Scripting attacks remain to be one of the fastest growing and most severe threats on the Open Web Platform. Considerable work is already done in the IETF’s WebSec Working Group and in the W3C’s Web Application Security Working Group, but several open problems remain to be addressed in the future. STREWS suggests to include recent research advances in this field in the works already under way to improve mitigating tools like Content Security Policies.
Flexible and secure clickjacking protection mechanism
Methods, systems, and computer-readable storage media for preventing a clickjacking attack on a web page. Implementations include inhibiting rendering of content of the web page, receiving a message from an embedding web page, the embedding web page having called the web page, the message including metadata, and determining whether the embedding web page is trusted based on the metadata, wherein rendering of content of the web page remains inhibited if the embedding web page is untrusted, and rendering of content of the web page is executed if the embedding web page is trusted.
Primer on client-side web security
This volume illustrates the continuous arms race between attackers and defenders of the Web ecosystem by discussing a wide variety of attacks. In the first part of the book, the foundation of the Web ecosystem is briefly recapped and discussed. Based on this model, the assets of the Web ecosystem are identified, and the set of capabilities an attacker may have are enumerated. In the second part, an overview of the web security vulnerability landscape is constructed. Included are selections of the most representative attack techniques reported in great detail. In addition to descriptions of the most common mitigation techniques, this primer also surveys the research and standardization activities related to each of the attack techniques, and gives insights into the prevalence of those very attacks. Moreover, the book provides practitioners a set of best practices to gradually improve the security of their web-enabled services. Primer on Client-Side Web Security expresses insights into the future of web application security. It points out the challenges of securing the Web platform, opportunities for future research, and trends toward improving Web security.
Mutual authentication schemes
Implementations of the present disclosure are directed to web-based authentication. Implementations include receiving user credentials at a browser, transmitting a first request to an application, the first request including a first user credential, receiving a first response, the first response including an encrypted server public key (SPK) and a user-specific salt value, decrypting the encrypted SPK to provide a SPK, the encrypted SPK being decrypted based on the user-specific salt value and a second user credential, determining a browser public key (BPK) and a client-side session signing key (SSK), encrypting the BPK to provide an encrypted BPK, transmitting a second request to the application, the second request including the encrypted BPK and a request signature, the request signature having been provided based on the client-side SSK, and receiving a second response, the second response including a response signature and indicating that a user has been authenticated by the application.
Real-time communications security on the web
With the introduction of Web Real-Time Communications (WebRTC), both Web technology and RTC have entered a new era. WebRTC is a joint effort of the W3C and IETF, supported by a large industry consortium. The technology offers real-time, peer-to-peer communication capabilities directly in the user's browser, accessible to websites via JavaScript APIs. Because of the numerous potential applications and the accessibility of the technology, WebRTC is expected to quickly become a game-changing technology in the communication landscape.
Case study 1 Report: WebRTC
Built-in handling of Real Time Media (audio, video) on the web promises potentially significant change in telephony and in conference calling. The W3C WebRTC and IETF rtcweb working groups are developing the set of specifications that will allow browsers and web sites to support such calling and other functions. This is clearly a potentially security sensitive extension to the web, so STREWS has devoted effort on this topic as a case study to both attempt to improve the overall security of the result and to see if this approach holds promise as a way to improve interactions between researchers and standards makers and hence the overall security of the web. In this deliverable, we show some possibly new issues with WebRTC security discovered by researchers (from SAP) that the standards makers may not have considered. However, while this deliverable is, as a deliverable, final, the work itself goes on, partly involving discussions between the STREWS project and participants in the IETF and W3C so in technical terms this remains a work-in-progress. (We have therefore updated this deliverable to take account of developments since the v1.0 version.)
Precise Client-side Protection against DOM-based Cross-Site Scripting.
The current generation of client-side Cross-Site Scripting filters rely on string comparison to detect request values that are reflected in the corresponding response’s HTML. This coarse approximation of occurring data flows is incapable of reliably stopping attacks which leverage nontrivial injection contexts. To demonstrate this, we conduct a thorough analysis of the current state-of-the-art in browser-based XSS filtering and uncover a set of conceptual shortcomings, that allow efficient creation of filter evasions, especially in the case of DOM-based XSS. To validate our findings, we report on practical experiments using a set of 1,602 real-world vulnerabilities, achieving a rate of 73% successful filter bypasses. Motivated by our findings, we propose an alternative filter design for DOM-based XSS, that utilizes runtime taint tracking and taint-aware parsers to stop the parsing of attackercontrolled syntactic content. To examine the efficiency and feasibility of our approach, we present a practical implementation based on the open source browser Chromium. Our proposed approach has a low false positive rate and robustly protects against DOM-based XSS exploits.
Journal of Computer Security Volume 22 Issue 4
An abstract is not available.
Script-templates for the content security policy
Content Security Policies (CSPs) provide powerful means to mitigate most XSS exploits. However, CSP’s protection is incomplete. Insecure server-side JavaScript generation and attacker control over script-sources can lead to XSS conditions which cannot be mitigated by CSP. In this paper we propose PreparedJS, an extension to CSP which takes these weaknesses into account. Through the combination of a safe script templating mechanism with a light-weight script checksumming scheme, PreparedJS is able to fill the identified gaps in CSP’s protection capabilities.
Protecting users against XSS-based password manager abuse
To ease the burden of repeated password authentication on multiple sites, modern Web browsers provide password managers, which offer to automatically complete password fields on Web pages, after the password has been stored once. Unfortunately, these managers operate by simply inserting the clear-text password into the document's DOM, where it is accessible by JavaScript. Thus, a successful Cross-site Scripting attack can be leveraged by the attacker to read and leak password data which has been provided by the password manager. In this paper, we assess this potential threat through a thorough survey of the current password manager generation and observable characteristics of password fields in popular Web sites. Furthermore, we propose an alternative password manager design, which robustly prevents the identified attacks, while maintaining compatibility with the established functionality of the existing approaches.
A trusted UI for the mobile web
Modern mobile devices come with first class web browsers that rival their desktop counterparts in power and popularity. However, recent publications point out that mobile browsers are particularly susceptible to attacks on web authentication, such as phishing or clickjacking. We analyze those attacks and find that existing countermeasures from desktop computers can not be easily transfered to the mobile world. The attacks’ root cause is a missing trusted UI for security critical requests. Based on this result, we provide our approach, the MobileAuthenticator, that establishes a trusted path to the web application and reliably prohibits the described attacks. With this approach, the user only needs one tool to protect any number of mobile web application accounts. Based on the implementation as an app for iOS and Android respectively, we evaluate the approach and show that the underlying interaction scheme easily integrates into legacy web applications.
Secure client-side key storage for web applications
Implementations of the present disclosure include methods, systems, and computer-readable storage mediums for secure client-side key storage for authentication tracking. Implementations include actions of determining, at a browser executed on a client-side computing device, that an application is authentic, the application being executed on a server-side computing device, in response to determining that the application is authentic, receiving a session signing key (SSK) at a sub-domain of an application domain, the sub-domain including a static script that handles the SSK and that selectively provides request signatures, receiving, at the sub-domain, a message requesting a request signature, determining that the message originated from an authentic origin, and in response to determining that the message originated from an authentic origin, providing a request signature to a source of the message, the request signature being based on the SSK.
PhishSafe: leveraging modern JavaScript API's for transparent and robust protection
The term "phishing" describes a class of social engineering attacks on authentication systems, that aim to steal the victim's authentication credential, e.g., the username and password. The severity of phishing is recognized since the mid-1990's and a considerable amount of attention has been devoted to the topic. However, currently deployed or proposed countermeasures are either incomplete, cumbersome for the user, or incompatible with standard browser technology. In this paper, we show how modern JavaScript API's can be utilized to build PhishSafe, a robust authentication scheme, that is immune against phishing attacks, easily deployable using the current browser generation, and requires little change in the end-user's interaction with the application. We evaluate the implementation and find that it is applicable to web applications with low efforts and causes no tangible overhead.
Technische Sicherheit und Informationssicherheit
Unsere Gesellschaft hängt in umfassendem Maße vom zuverlässigen Funktionieren technischer Systeme und vom jederzeit möglichen Zugriff auf authentische und korrekte Informationen ab. Innerhalb dieser technischen Systeme spielen informationsspeichernde bzw. -verarbeitende Systeme eine immer größere Rolle; in einzelnen Branchen tragen sie mittlerweile über 50 % zur Wertschöpfung bei [1]. Diese Systeme, egal wo sie eingesetzt werden (z. B. in Rechenzentren, Banken, Autos usw.) sollen im Folgenden als IT-Systeme (kurz für: informationstechnische Systeme) bezeichnet werden. Durch ihre Funktion können sich technische Systeme in allen Lebensbereichen und auf alle vorstellbaren Werte auswirken, die sämtliche für Nutzer bedeutsame Aspekte umfassen, etwa menschliches Leben, Gesundheit und Unversehrtheit, Vermögen, Wissen, Gegenstände und persönliche Daten beteiligter ebenso wie nur mittelbar beteiligter Personen. Im Allgemeinen muss man davon ausgehen, dass technische Systeme nicht immer fehlerlos sind und arbeiten, sondern dass sie von Beginn an bestehende oder erst mit der Zeit auftretende Schwachstellen enthalten. Schwachstellen können selbst bei bestimmungsgemäßem Gebrauch eines technischen Systems zu Fehlfunktionen führen, durch die Personen, Umwelt, Infrastruktur oder Daten geschädigt werden. Erst recht kann die funktional falsch verstandene oder grundsätzlich unsachgemäße Benutzung technischer, auch korrekt funktionierender Systeme die oben genannten Werte beeinträchtigen. Die vielfältigen Probleme und Aspekte bezüglich der Sicherung von IT-Systemen gegen derartige Effekte gewinnen zunehmend an Bedeutung Im Arbeitskreis ,,Begriffsbildung“ des GIFachbereichs ,,Sicherheit“ ist in den letzten Jahren in intensiven Diskussionen versucht worden, Grundbegriffe zur Charakterisierung dieses Problembereichs, die in der Fachöffentlichkeit mit teilweise divergierender Bedeutung benutzt wurden, präziser zu fassen. Als Resultat dieser Arbeiten wird in der vorliegenden Veröffentlichung auf die Bedeutung solcher unterschiedlicher, umgangssprachlich oftmals synonym gebrauchter Begriffe eingegangen, die nach Auffassung der Autoren einer differenzierten Betrachtung bedürfen. Die Arbeit ist wie folgt aufgebaut: Abschnitt ,,Grundbegriffe“ beschreibt einige Grundbegriffe aus dem Unfallwesen. Dann wird in Abschnitt ,,Sicherheitskonzepte“ eine Reihe von Definitionen zur genaueren Charakterisierung des Begriffs ,,Sicherheit“ vorgestellt. Danach diskutiert Abschnitt ,,Sicherheit von IT-Systemen einschließlich ihrer Umgebung“ die Übertragung dieser Notation auf IT-Systeme. Abschnitt ,,Die Sicherheitsterminologie im englisch beeinflussten Sprachgebrauch: Safety vs. Security und ihre terminologischen Unterfütterungen“ bringt einen Überblick über die verschiedenen Interpretationen der Begriffe ,,Safety“ und ,,Security“. Abschließend werden in Abschnitt ,,Technische Sicherheit und Informationssicherheit“ die Begriffe ,,Technische Sicherheit“ und ,,Informationssicherheit“ behandelt.
DOM-basiertes Cross-Site Scripting im Web: Reise in ein unerforschtes Land.
Cross-site Scripting (XSS) ist eine weit verbreitete Verwundbarkeitsklasse in Web-Anwendungen und kann sowohl von server-seitigem als auch von clientseitigem Code verursacht werden. Allerdings wird XSS primar als ein server-seitiges ¨ Problem wahrgenommen, motiviert durch das Offenlegen von zahlreichen entsprechenden XSS-Schwachen. In den letzten Jahren jedoch kann eine zunehmende ¨ Verlagerung von Anwendungslogik in den Browser beobachtet werden eine Entwicklung die im Rahmen des sogenannten Web 2.0 begonnen hat. Dies legt die Vermutung nahe, dass auch client-seitiges XSS an Bedeutung gewinnen konnte. In diesem Beitrag ¨ stellen wir eine umfassende Studie vor, in der wir, mittels eines voll-automatisierten Ansatzes, die fuhrenden 5000 ¨ Webseiten des Alexa Indexes auf DOM-basiertes XSS untersucht haben. Im Rahmen dieser Studie, konnten wir 6.167 derartige Verwundbarkeiten identifizieren, die sich auf 480 der untersuchten Anwendungen verteilen.
A tale of the weaknesses of current client-side XSS filtering
Cross-Site Scripting (XSS) is one of the most severe security vulnerabilities of the Web. With the introduction of HTML5, the complexity of Web applications is ever increasing and despite the existence of robust protection libraries, Cross-Site Scripting vulnerabilities are nowadays omnipresent on the Web. In order to protect end users from being exploited, browser vendors reacted to this serious threat by outfitting their browsers with client-side XSS filters. Unfortunately, as we had to notice, the currently provided protection is severely limited, leaving end-users vulnerable to exploits in the majority of cases. In this paper, we present an analysis of Chrome’s XSS Auditor, in which we discovered 17 flaws, that enable us to bypass the Auditor’s filtering capabilities. We will demonstrate the bypasses and report on a tool to automatically generated XSS attacks utilizing the bypasses. Furthermore, we will report on a practical, empirical study of the Auditor’s protection capabilities in which we ran our generated attacks against a set of several thousand DOM-based, zero-day XSS vulnerabilities in the Alexa Top 10.000. In our experiments, we were able to successfully bypass the XSS filter on first try in over 80% of all vulnerable Web applications.
The Relevance of Client-Side Web Security
The Web has evolved from a static distributed hypertext system into a rich application platform, where the browser is capable of running highly dynamic client-side applications, which merely depend on backend server-side services for data storage. We observe a similar trend within the field of Web security, where more responsibilities are pushed towards the client side. Security mechanisms have evolved from default browser policies that are the same for all applications to server-driven security policies composed at the server side and enforced at the client side. This chapter briefly sketches the trends in the evolution of the Web and the parallels in the field of Web security. We introduce a social networking example scenario that will serve as a working example throughout this book. Finally, we provide a reader’s guide for the intended target audiences, which include students, teachers, trainers, researchers, developers, and security practitioners.
Traditional Building Blocks of the Web
Traditional Web applications seem vastly different from modern applications, which thrive on technological advances with dynamic content loading, background processing, and continuous data feeds. However, under the hood, these modern applications still rely on the same building blocks used by traditional applications. This chapter briefly introduces these building blocks as required background knowledge, followed by a discussion of several relevant client-side features. These include the browser’s security policies, which are all the more important today, the client-side extensibility features using plugins and browser extensions, and browser features aimed at enhancing the user experience, such as security indicators and private browsing modes.
Attacks on the Client Device
By directly attacking the client device, the attacker can gain control over the device, allowing him/her to manipulate the user’s actions, steal sensitive information or abuse the device for other activities, such as denial of service attacks. In this chapter, we discuss two important attack vectors. The first attack vector uses drive-by download techniques to exploit a memory corruption vulnerability in the client software, for example, a buffer overflow vulnerability in the browser. The second attack vector attacks the client device through a malicious browser extension, which is characterized by a high degree of control over the browser.
Attacks on the User’s Session
By attacking the user’s session, an attacker can gain control over an authenticated session, giving him the same level of access to the target application as the victim. Unfortunately, applications often deploy weak authentication systems and insufficiently protect authenticated sessions, thereby enabling these attacks. In this chapter, we cover two attacks that enable the attacker to transfer an authenticated session from the victim’s browser to his own: session-hijacking and Session fixation. In addition, we cover the impact of credential theft, a common attack that gives the attacker valid user credentials, allowing him to impersonate a user to the target application. Attacks on the user’s session are common, and are supported by various tools and attack frameworks.
Attacks on the Network
By executing a network attack, an attacker is able to eavesdrop on a user’s traffic, or even manipulate the traffic while it is in transit. By itself, the scope of a network attack is limited to inspecting and manipulating traffic on the network. However, this capability often serves as a stepping stone, resulting in an escalation towards impersonating the user, taking control of the user’s browser, etc. In this chapter, we cover three varieties of network attacks. First, we discuss an eavesdropping attack, where the attacker listens in on the traffic being sent. Next, we cover man-in-the-middle attacks, where the attacker can also manipulate the traffic while in transit. Finally, we discuss attacks on the Hypertext Transfer Protocol (HTTPS) protocol, which uses the Transport Layer Security (TLS) to offer certain security guarantees.
Attacks on the Client-Side Context
Using attacks on the client-side context, the attacker can gain control over the target application running in the user’s browser. This allows him to steal the user’s sensitive information and manipulate the user’s actions. From the Web application’s point of view, these actions are indistinguishable from legitimate user actions. In this chapter, we investigate three ways of attacking the client-side context. The first is cross-site scripting (XSS), a very common and well-known attack, where the attacker injects JavaScript into the target application’s context. Second, we discuss scriptless attacks, which take the idea behind XSS, but use non-scripting technology to extract data or modify the application’s behavior. Finally, we investigate the dangers of remote script inclusions, which are ubiquitous on the Web, but prone to compromise.
How Attackers Threaten the Web
Since the Web is an important application platform, it is a high profile target for attackers. Different attackers have different capabilities, and certain vulnerabilities require a specific set of capabilities to be exploited. These capabilities are generally captured in a threat model, describing what an attacker can and cannot do. In this chapter, we provide an overview of the relevant academic threat models for the Web. Since these models are often highly tailored to a specific problem statement and solution, their slight differences make it difficult to compare threat models. Therefore, we decompose every threat model into concrete attacker capabilities, enabling a conceptual comparison of the threat models.
The Browser as a Platform
The browser is the single, most valuable tool for enabling users to access the Web. Browser vendors realize this, which is why domination in the browser market share has been a high-stakes game since the 1990s. In this chapter, we take a look at how browsers can be found on numerous devices today, including mobile devices and smart appliances. We investigate how the browser evolved from a static rendering engine into a full-featured Web application platform, offering Web applications access to local storage facilities, sensor information, communication mechanisms, and more. Finally, we discuss Firefox OS and Google’s Chrome OS that have given the browser the status of an operating system.
Improving Client-Side Web Security
The previous chapters have covered a wide variety of attacks, which over the chapters came closer and closer to the user himself, eventually leading to the compromise of the browser and client device. In this chapter, we compile an overview of the best practices scattered throughout the previous chapters, resulting in a practical guide for securing Web applications in the modern age Web. We also look into the crucial role of research in Web security and identify future research challenges.
Attacks on the browser’s requests
By attacking the browser’s requests, an attacker is able to trick the user’s browser into sending requests to a target application. Since these requests originate from the user’s browser, a vulnerable application is unable to distinguish them from legitimate requests, thus allowing the attacker to perform actions in the user’s name. The two most common ways of forging requests from the user’s browser are cross-site request forgery (CSRF), where requests are automatically sent by the browser, and UI redressing, where the user is tricked into interacting with a seemingly innocent page, while the interactions are actually sent to the target application. Real-life attacks on vulnerable applications have allowed attackers to transfer money from bank accounts, take over accounts through the password reset feature or secretly enable the webcam in the Flash player.
Lightweight Integrity Protection for Web Storage-Driven Content Caching
Methods, systems, and computer-readable storage media for providing integrity protection for web storage-driven content caching. Implementations include receiving a web page from a server, the web page being associated with a script library and one or more items that can be stored in web storage of a web browser executed on a client computing device, each of the one or more items being associated with a pre-determined checksum value, and loading the script library, such that a local storage API is overwritten using a wrapper function, the script library being executable to, in response to a request for an item from web storage, perform operations including: determining a generated checksum value based on the item, and verifying an integrity of the item based on the generated checksum value and a pre-determined checksum value associated with the item.
25 million flows later: Large-scale detection of DOM-based XSS
In recent years, the Web witnessed a move towards sophis- ticated client-side functionality. This shift caused a signifi- cant increase in complexity of deployed JavaScript code and thus, a proportional growth in potential client-side vulnera- bilities, with DOM-based Cross-site Scripting being a high impact representative of such security issues. In this paper, we present a fully automated system to detect and validate DOM-based XSS vulnerabilities, consisting of a taint-aware JavaScript engine and corresponding DOM implementation as well as a context-sensitive exploit generation approach. Using these components, we conducted a large-scale analysis of the Alexa top 5000. In this study, we identified 6167 unique vulnerabilities distributed over 480 domains, show- ing that 9,6% of the examined sites carry at least one DOM- based XSS problem.
Tamper-resistant likejacking protection
The ClickJacking variant LikeJacking specifically targetsWeb widgets that offer seamless integration of third party services, such as social sharing facilities. The standard defense against ClickJacking is preventing framing completely or allowing framing only in trusted contexts. These measures cannot be taken in the case of LikeJacking, due to the widgets’ inherent requirement to be available to arbitrary Web applications. In this paper, we report on advances in implementing LikeJacking protection that takes the specific needs of such widgets into account and is compatible with current browsers. Our technique is based on three pillars: A JavaScript-driven visibility check, a secure in-browser communication protocol, and a reliable method to validate the integrity of essential DOM properties and APIs. To study our protection mechanism’s performance characteristics and interoperability with productive Web code, we applied it to 635 real-world Web pages. The evaluation’s results show that our method performs well even for large, non-trivial DOM structures and is applicable without requiring changes for the majority of the social sharing widgets used by the tested Web applications.
Eradicating DNS Rebinding with the Extended Same-origin Policy.
The Web’s principal security policy is the Same-Origin Policy (SOP), which enforces origin-based isolation of mutually distrusting Web applications. Since the early days, the SOP was repeatedly undermined with variants of the DNS Rebinding attack, allowing untrusted script code to gain illegitimate access to protected network resources. To counter these attacks, the browser vendors introduced countermeasures, such as DNS Pinning, to mitigate the attack. In this paper, we present a novel DNS Rebinding attack method leveraging the HTML5 Application Cache. Our attack allows reliable DNS Rebinding attacks, circumventing all currently deployed browserbased defense measures. Furthermore, we analyze the fundamental problem which allows DNS Rebinding to work in the first place: The SOP’s main purpose is to ensure security boundaries of Web servers. However, the Web servers themselves are only indirectly involved in the corresponding security decision. Instead, the SOP relies on information obtained from the domain name system, which is not necessarily controlled by the Web server’s owners. This mismatch is exploited by DNS Rebinding. Based on this insight, we propose a light-weight extension to the SOP which takes Web server provided information into account. We successfully implemented our extended SOP for the Chromium Web browser and report on our implementation’s interoperability and security properties.
Preparedjs: Secure script-templates for javascript
Content Security Policies (CSP) provide powerful means to mitigate most XSS exploits. However, CSP’s protection is incomplete. Insecure server-side JavaScript generation and attacker control over script-sources can lead to XSS conditions which cannot be mitigated by CSP. In this paper we propose PreparedJS, an extension to CSP which takes these weaknesses into account. Through the combination of a safe script templating mechanism with a light-weight script checksumming scheme, PreparedJS is able to fill the identified gaps in CSP’s protection capabilities.
Dagstuhl Reports, Vol. 2, Issue 10 ISSN 2192-5283
This report documents the program and the outcomes of Dagstuhl Seminar 12401 “Web Application Security”. The seminar brought 44 web security researchers together, coming from companies and research institutions across Europe and the US. The seminar had a well-filled program, with 3 keynotes, 28 research talks, and 15 5-minute talks. As web application security is a broad research domain, a diverse set of recent research results was presented during the talks, covering the web security vulnerability landscape, information-flow control, JavaScript formalization, JavaScript confinement, and infrastructure and server hardening. In addition to the plenary program, the seminar also featured three parallel break-out sessions on Cross-Site Scripting (XSS), JavaScript and Information-flow control.
Web-platform security guide: Security assessment of the web ecosystem
In this document, we report on the Web-platform security guide, which has been developed within the EC-FP7 project STREWS. Based on their research, the STREWS consortium argues that in order to strengthening the Internet (e.g. against pervasive monitoring), it is crucial to also strengthen the web app
Web Application Security (Dagstuhl Seminar 12401)
This report documents the program and the outcomes of Dagstuhl Seminar 12401 "Web Application Security". The seminar brought 44 web security researchers together, coming from companies and research institutions across Europe and the US. The seminar had a well-filled program, with 3 keynotes, 28 research talks, and 15 5-minute talks. As web application security is a broad research domain, a diverse set of recent research results was presented during the talks, covering the web security vulnerability landscape, information-flow control, JavaScript formalization, JavaScript confinement, and infrastructure and server hardening. In addition to the plenary program, the seminar also featured three parallel break-out sessions on Cross-Site Scripting (XSS), JavaScript and Information-flow control.
BetterAuth: web authentication revisited
This paper presents "BetterAuth", an authentication protocol for Web applications. Its design is based on the experiences of two decades with the Web. BetterAuth addresses existing attacks on Web authentication, ranging from network attacks to Cross-site Request Forgery up to Phishing. Furthermore, the protocol can be realized completely in standard JavaScript. This allows Web applications an early adoption, even in a situation with limited browser support.
DEMACRO: Defense against malicious cross-domain requests
In the constant evolution of theWeb, the simple always gives way to the more complex. Static webpages with click-through dialogues are becoming more and more obsolete and in their place, asynchronous JavaScript requests, Web mash-ups and proprietary plug-ins with the ability to conduct cross-domain requests shape the modern user experience. Three recent studies showed that a significant number ofWeb applications implement poor cross-domain policies allowing malicious domains to embed Flash and Silverlight applets which can conduct arbitrary requests to these Web applications under the identity of the visiting user. In this paper, we confirm the findings of the aforementioned studies and we design DEMACRO, a client-side defense mechanism which detects potentially malicious cross-domain requests and de-authenticates them by removing existing session credentials. Our system requires no training or user interaction and imposes minimal performance overhead on the user’s browser.
A user-level authentication scheme to mitigate web session-based vulnerabilities
After the initial login, web browsers authenticate to web applications by sending the session credentials with every request. Several attacks exist which exploit conceptual deficiencies of this scheme, e.g. Cross-Site Request Forgery, Session Hijacking, Session Fixation, and Clickjacking. We analyze these attacks and identify their common root causes in the browser authentication scheme and the missing user context. These root causes allow the attacker to mislead the browser and misuse the user’s session context. Based on this result, we present a user authentication scheme that prohibits the exploitation of the analyzed vulnerabilities. Our mechanism works by binding image data to individual sessions and requiring submission of this data along with security-critical HTTP requests. This way, an attacker’s exploitation chances are limited to a theoretically arbitrary low probability to guess the correct session image.
Websand: Server-driven outbound web-application sandboxing
WebSand tackles security beyond dealing with low-level vulnerabilities at a higher level of abstraction: The technical strategy is to deal with security in a server-driven fashion. Clearly, security preferences and requirements from endusers at the client-side need to be taken into account, but primarily service developers at the server-side have the required expertise and context information to define adequate policies to be enforced. Moreover, server-driven security can be deployed relatively easily, since the need for updating the client-side platform is minimized. Since WebSand strands for “Server-driven Outbound Web-application Sandboxing”, the project’s overall goal is –along with this strategy– to empower web application developers, service providers, and users in designing, implementing, and running secure applications: Developers and service providers can develop and deploy secure web applications on their application servers; users will benefit from the project’s results by transparently receiving a suitable security platform for their applications. WebSand aims to deliver this non-disruptively, i.e. by building upon existing web application technologies wherever possible to allow a seamless, immediate adoption of results in existing and future web applications.
Lightweight Integrity Protection for Web Storage-driven Content Caching
The term Web storage summarizes a set of browserbased technologies that allow application-level persistent storage of key/values pairs on the client-side. These capabilities are frequently used for caching of markup or script code fragments, e.g., in scenarios with specific bandwidth or responsiveness requirements. Unfortunately, this practice is inherently insecure, as it may allow attackers to inject malicious JavaScript payloads into the browser’s Web storage. Such payloads reside in the victim’s browser for a potentially prolonged period and lead to resident compromise of the application’s client-side code. In this paper, we first present three possible attack scenarios that showcase how an attacker is able to inject code into web storage. Then we verify that Web storage is indeed used in the outlined, insecure fashion, via a large-scale study of the top 500.000 Alexa domains. Furthermore, we propose a lightweight integrity protecting mechanism that allows developers to store markup and code fragments in Web storage without risking a potential compromise. Our protection approach can be introduced without requiring browser modifications and introduces only negligible performance overhead.
HTML5-Security
In the past, web browsers have always been extremely negative when it comes to security. Much of these abuses have been recognized and improved over the past few years. Now, HTML5, the next level of browser evolution, is on our doorstep. Marked by the bad experiences of the previous development, one meets the newly introduced browser features in many places with distrust. This article introduces the security properties of three prominent HTML5 JavaScript APIs.
usenix conference policies
An important and timely attack technique on the Web is Clickjacking (also called UI redressing), in which an attacker tricks the unsuspicious victim into clicking on a specific element without his explicit knowledge about where he is actually clicking. In order to protect their websites from being exploitable, many web masters deployed different countermeasures to this kind of attack. In this paper, we explore the limitations and shortcomings of current anti-clickjacking approaches and present several bypasses of state-of-the-art tools, including an attack we call Nested Clickjacking that enables us to perform Clickjacking against the social network Google+. Furthermore, we present the results of a large scale empirical study on the usage of current anti-clickjacking mechanisms on about 2 million web pages. The results of our analysis show that about 15% of the analyzed web sites protect themselves against Clickjacking.
Towards stateless, client-side driven Cross-Site Request Forgery protection for Web applications.
Cross-site request forgery (CSRF) is one of the dominant threats in the Web application landscape. In this paper, we present a lightweight and stateless protection mechanism that can be added to an existing application without requiring changes to the application’s code. The key functionality of the approach, which is based on the double-submit technique, is purely implemented on the client-side. This way full coverage of client-side generation of HTTP requests is provided.
On the fragility and limitations of current Browser-provided Clickjacking protection schemes
An important and timely attack technique on the Web is Clickjacking (also called UI redressing), in which an attacker tricks the unsuspicious victim into clicking on a specific element without his explicit knowledge about where he is actually clicking. In order to protect their websites from being exploitable, many web masters deployed different countermeasures to this kind of attack. In this paper, we explore the limitations and shortcomings of current anti-clickjacking approaches and present several bypasses of state-of-the-art tools, including an attack we call Nested Clickjacking that enables us to perform Clickjacking against the social network Google+. Furthermore, we present the results of a large scale empirical study on the usage of current anti-clickjacking mechanisms on about 2 million web pages. The results of our analysis show that about 15% of the analyzed web sites protect themselves against Clickjacking.
Decentralized intelligence in energy efficient power systems
Power systems are increasingly built from distributed generation units and smart consumers that are able to react to grid conditions. Managing this large number of decentralized electricity sources and flexible loads represent a very huge optimization problem. Both from the regulatory and the computational perspective, no one central coordinator can optimize this overall system. Decentralized control mechanisms can, however, distribute the optimization task through price signals or market-based mechanisms. This chapter presents the concepts that enable a decentralized control of demand and supply while enhancing overall efficiency of the electricity system. It highlights both technological and business challenges that result from the realization of these concepts, and presents the state-of-the-art in the respective domains.
Smart metering de-pseudonymization
Consumption traces collected by Smart Meters are highly privacy sensitive data. For this reason, current best practice is to store and process such data in pseudonymized form, separating identity information from the consumption traces. However, even the consumption traces alone may provide many valuable clues to an attacker, if combined with limited external indicators. Based on this observation, we identify two attack vectors using anomaly detection and behavior pattern matching that allow effective depseudonymization. Using a practical evaluation with real-life consumption traces of 53 households, we verify the feasibility of our techniques and show that the attacks are robust against common countermeasures, such as resolution reduction or frequent re-pseudonymization.
Plug-in privacy for smart metering billing
Traditional electricity meters are replaced by Smart Meters in customers’ households. Smart Meters collect fine-grained utility consumption profiles from customers, which in turn enables the introduction of dynamic, time-of-use tariffs. However, the fine-grained usage data that is compiled in this process also allows to infer the inhabitant’s personal schedules and habits. We propose a privacy-preserving protocol that enables billing with time-of-use tariffs without disclosing the actual consumption profile to the supplier. Our approach relies on a zero-knowledge proof based on Pedersen Commitments performed by a plug-in privacy component that is put into the communication link between Smart Meter and supplier’s back-end system. We require no changes to the Smart Meter hardware and only small changes to the software of Smart Meter and back-end system. In this paper we describe the functional and privacy requirements, the specification and security proof of our solution and give a performance evaluation of a prototypical implementation.
Biting the hand that serves you: A closer look at client-side flash proxies for cross-domain requests
Client-side Flash proxies provide an interface for JavaScript applications to utilize Flash’s cross-domain HTTP capabilities. However, the subtle differences in the respective implementations of the same-origin policy and the insufficient security architecture of the JavaScript-to-Flash interface lead to potential security problems. We comprehensively explore these problems and conduct a survey of five existing proxy implementation. Furthermore, we propose techniques to avoid the identified security pitfalls and to overcome the untrustworthy interface between the two technologies.
The state of the cross-domain nation
We did an exhaustive survey on the current practice of permitting client-side cross-domain HTTP requests ! Flash, Silverlight (and CORS) Result: A considerable fraction of sites utilize potentially insecure policies
Abusing locality in shared web hosting
The increasing popularity of the World Wide Web has made more and more individuals and companies to identify the need of acquiring a Web presence. The most common way of acquiring such a presence is through Web hosting companies and the most popular hosting solution is shared Web hosting. In this paper we investigate the workings of shared Web hosting and we point out the potential lack of session isolation between domains hosted on the same physical server. We present two novel server-side attacks against session storage which target the logic of a Web application instead of specific logged-in users. Due to the lack of isolation, an attacker with a domain under his control can force arbitrary sessions to co-located Web applications as well as inspect and edit the contents of their existing active sessions. Using these techniques, an attacker can circumvent authentication mechanisms, elevate his privileges, steal private information and conduct attacks that would be otherwise impossible. Finally, we test the applicability of our attacks against common open-source software and evaluate their effectiveness in the presence of generic server-side countermeasures.
Scanstud: a methodology for systematic, fine-grained evaluation of static analysis tools
Static analysis of source code is considered to be a powerful tool for detecting potential security vulnerabilities. However, only limited information regarding the current quality of static analysis tools exist. A public assessment of the capabilities of the competing approaches and products is not available. Also, neither a common benchmark nor a standard evaluation procedure has yet been defined. In this paper, we propose a general methodology for systematically evaluating static analysis tools. We document the design of an automatic execution and evaluation framework to support iterative test case design and reliable result analysis. Furthermore, we propose a methodology for creating test cases which can assess the specific capabilities of static analysis tools on a very fine level of detail. We conclude the paper with a brief discussion of our experiences which we collected through a practical evaluation study of six commercial static analysis products.
Reliable protection against session fixation attacks
The term 'Session Fixation vulnerability' subsumes issues in Web applications that under certain circumstances enable the adversary to perform a Session Hijacking attack through controlling the victim's session identifier value. A successful attack allows the attacker to fully impersonate the victim towards the vulnerable Web application. We analyse the vulnerability pattern and identify its root cause in the separation of concerns between the application logic, which is responsible for the authentication processes, and the framework support, which handles the task of session tracking. Based on this result, we present and discuss three distinct server-side measures for mitigating Session Fixation vulnerabilities. Each of our countermeasures is tailored to suit a specific real-life scenario that might be encountered by the operator of a vulnerable Web application.
SessionShield: Lightweight protection against session hijacking
The class of Cross-site Scripting (XSS) vulnerabilities is the most prevalent security problem in the field of Web applications. One of the main attack vectors used in connection with XSS is session hijacking via session identifier theft. While session hijacking is a client-side attack, the actual vulnerability resides on the server-side and, thus, has to be handled by the website’s operator. In consequence, if the operator fails to address XSS, the application’s users are defenseless against session hijacking attacks. In this paper we present SessionShield, a lightweight client-side protection mechanism against session hijacking that allows users to protect themselves even if a vulnerable website’s operator neglects to mitigate existing XSS problems. SessionShield is based on the observation that session identifier values are not used by legitimate client-side scripts and, thus, need not to be available to the scripting languages running in the browser. Our system requires no training period and imposes negligible overhead to the browser, therefore, making it ideal for desktop and mobile systems.
Session hijacking attacks
The term Session hijacking attacks refers to a class of attacks specific to Web applications. It describes situations in which the adversary impersonates a Web application’s user through unauthorized usage of session credentials within adversary-controlled HTTP requests.
Security challenges of a changing energy landscape
The German electric energy industry is under change. The Smart Grid, Smart Metering and electric mobility are being researched and implemented. It will have implications for the security and privacy of our everyday-lives if security and privacy are not taken into account during this change. Therefore the identification and mitigation of security and privacy issues of prospective technologies is essential before respective systems are built. In this paper we identify the current legislative measures to induce change, derive the necessary technical changes and analyze them with respect to security and privacy challenges. We identify several security and privacy challenges: New paradigms like mobile energy consumers or bidirectional communication with electrical meters, isolated systems like Industrial Control Systems or Home Automation Networks that will eventually be connected to public networks and huge amounts of privacy-related data that will be created by respective systems. We conclude that the energy sector is an interesting field for security and privacy research and that now is the time to ensure a secure and private future of energy supply.
Code-injection Vulnerabilities in Web Applications—Exemplified at Cross-site Scripting
Cross-site Scripting (XSS) is one of the most prevalent vulnerability types that affect Web applications. This article provides an overview of a dissertation, which addresses the problem XSS as a whole: It starts with a systematic deduction of causes and consequences of XSS, proceeds with presenting countermeasures to mitigate potential XSS-based attacks, and finally provides a type-based methodology that guarantees the creation of XSS-free applications.
Usb device drivers: A stepping stone into your kernel
The widely–used Universal Serial Bus (USB) exposes a physical attack vector which has received comparatively little attention in the past. While most research on device driver vulnerabilities concentrated on wireless protocols, we show that USB device drivers provide the same potential for vulnerabilities but offer a larger attack surface resulting from the universal nature of the USB protocol. To demonstrate the effectiveness of fuzzing USB device drivers, we present our prototypical implementation of a mutation–based, man-in-the-middle USB fuzzing framework based on an emulated environment. We practically applied our framework to fuzz the communication between an Apple iPod device and a WindowsXP system. This way, we found several potential vulnerabilities. This supports our claim that the USB architecture exposes real attack vectors and should be considered when assessing the physical security of computer systems in the future.
Secure code generation for web applications
A large percentage of recent security problems, such as Cross-site Scripting or SQL injection, is caused by string-based code injection vulnerabilities. These vulnerabilities exist because of implicit code creation through string serialization. Based on an analysis of the vulnerability class’ underlying mechanisms, we propose a general approach to outfit modern programming languages with mandatory means for explicit and secure code generation which provide strict separation between data and code. Using an exemplified implementation for the languages Java and HTML/JavaScript respectively, we show how our approach can be realized and enforced.
Session Fixation-The Forgotten Vulnerability?
The term ‘Session Fixation vulnerability’ subsumes issues in Web applications that under certain circumstances enable the adversary to perform a session hijacking attack through controlling the victim’s session identifier value. We explore this vulnerability pattern. First, we give an analysis of the root causes and document existing attack vectors. Then we take steps to assess the current attack surface of Session Fixation. Finally, we present a transparent server-side method for mitigating vulnerabilities.
Code-injection Verwundbarkeit in Web Anwendungen am Beispiel von Cross-site Scripting.
Cross-site Scripting (XSS) dominiert seit einigen Jahren die Verwundbarkeitsstatistiken. Die hier zusammengefasste Dissertation prasentiert eine methodische ¨ Behandlung dieser Klasse von Sicherheitsproblemen. Wir bearbeiten das Problem in drei Schritten: (1) Nach einer Darlegung der notwendigen technischen Grundlagen erfassen wir uber eine Klassifikation der Menge der ¨ existierenden Angriffstypen das Bedrohungspotential von XSS. (2) Darauf aufbauend entwickeln wir geeignete technische Schutzmethoden vor XSS Angriffen zur Laufzeit. (3) Schlussendlich, zeigen wir, wie XSS Verwundbarkeiten durch das Erzwingen von strikter Daten/Code Trennung auf Sprachebene grundsatzlich und ¨ verlasslich ¨ verhindert werden konnen.
Dagstuhl Seminar 09141 Web Application Security - Executive Summary
Web applications are ubiquitous nowadays. Consequently, the field of Web application security is of ever rising significance. This Dagstuhl seminar was conducted to assemble researchers active in the domain to gain a first comprehensive overview of this young discipline in security research. From a content perspective, the topic was explored in a great variety of directions, including for instance Web browser-based security measures, language-based techniques, software engineering centric methods, run-time enforcement, static analysis, or formal approaches.
Dagstuhl Seminar 09141 Web Application Security - Abstracts Collection
From 29th March to 3rd April 2009 the Dagstuhl Seminar 09141 Web Application Security was held in Schloss Dagstuhl -- Leibniz Center for Informatics. During the seminar, several participants presented their current research, and ongoing work and open problems were discussed. Abstracts of the presentations given during the seminar are put together in this paper. Links to full papers (if available) are provided in the corresponding seminar summary document.
Xssds: Server-side detection of cross-site scripting attacks
Cross-site Scripting (XSS) has emerged to one of the most prevalent type of security vulnerabilities. While the reason for the vulnerability primarily lies on the server-side, the actual exploitation is within the victim's web browser on the client-side. Therefore, an operator of a web application has only very limited evidence of XSS issues. In this paper, we propose a passive detection system to identify successful XSS attacks. Based on a prototypical implementation, we examine our approach's accuracy and verify its detection capabilities. We compiled a data-set of 500.000 individual HTTP request/response-pairs from 95 popular web applications for this, in combination with both real word and manually crafted XSS-exploits; our detection approach results in a total of zero false negatives for all tests, while maintaining an excellent false positive rate for more than 80% of the examined web applications.
On JavaScript malware and related threats
The term JavaScript Malware describes attacks that abuse the web browser’s capabilities to execute malicious script-code within the victim’s local execution context. Unlike related attacks, JavaScript Malware does not rely on security vulnerabilities in the web browser’s code but instead solely utilizes legal means in respect to the applying specification documents. Such attacks can either invade the user’s privacy, explore and exploit the LAN, or use the victimized browser as an attack proxy. This paper documents the state of the art concerning this class of attacks, sums up relevant protection approaches, and provides directions for future research.