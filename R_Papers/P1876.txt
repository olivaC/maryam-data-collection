Special section on ICSM 2011
The IEEE International Conference on Software Maintenance (ICSM) is the premiere international venue in software maintenance and evolution, where participants from academia, government, and industry meet and share ideas and experiences for solving critical software maintenance problems. In 2011, the 27th edition of ICSM was held at the Williamsburg Lodge, in the heart of Williamsburg, VA, USA. Williamsburg, once the capital of England's oldest, wealthiest, and most populous North American colony, is one of the most important American historical landmarks. ICSM 2011 was held from September 25 to 30, 2011. The conference was preceded by two co‐located events, the 11th IEEE International Working Conference on Source Code Analysis and Manipulation (SCAM) and the International Workshop on the Maintenance and Evolution of Service‐Oriented and Cloud‐Based Systems (MESOCA). It was followed by two other co‐located events, the 13th IEEE International Symposium on Web Systems Evolution (WSE) and the 6th IEEE International Workshop on Visualizing Software for Understanding and Analysis (VISSOFT). ICSM 2011 attracted 127 submissions, each of which was reviewed by at least three members of the ICSM Program Committee. Following a week and a half of online discussion supported by EasyChair, 36 papers were selected for publication and presentation in the Technical Program of the conference. Consensus was aimed for and reached in almost all cases. The topics of accepted papers ranged from Reverse Engineering and Program Comprehension to Impact Analysis, Traceability, Migration and Evolution, Refactoring, Software Clones, Linguistic Analysis, and Regression Testing. The conference program included the ICSM Doctoral Symposium, Tutorials, Tool Demonstrations, Posters, the Industry track, and the Early Research Achievements track. This special section of the Journal of Software: Evolution and Process contains extended versions of the papers selected by the ICSM 2011 Program Committee among the best papers presented at the conference. These extended versions have additionally undergone the rigorous JSEP journal review process: they were reviewed by three anonymous referees under the supervision and coordination of the guest editors. We are proud to present you the three excellent papers that are the results of this process. Paper 1, ‘An empirical study of faults in late propagation clone genealogies’, by Liliane Barbour, Foutse Khomh, and Ying Zou, investigates the history of clone evolution over time, focusing on the phenomenon of late propagation. Late propagation occurs whenever one of two clones diverges from the other, as a result of code evolution, while later such changes are reconciled, so as to remove the divergence. The authors have defined eight types of late propagation, and they have evaluated empirically the relationship between fault proneness and late propagation of various type. They have also investigated whether reconciling changes are fault‐fixing changes. This paper contributes to our knowledge of the risks associated with clones and with their evolution over time. Paper 2, ‘Evaluating test‐to‐code traceability recovery methods through controlled experiments’, by Abdallah Qusef, Gabriele Bavota, Rocco Oliveto, Andrea De Lucia, and David Binkley, presents a combination of two controlled experiments comparing the effectiveness of four different approaches to recovering traceability links between test cases and code. Traceability addresses the problem of identifying links between software artifacts of different types, and test‐to‐code traceability addresses the issue of identifying precisely which sections of code are actually tested by a given test case. In the experiments presented in this paper, the effectiveness of the four approaches on three large Java systems is compared using a manual consensus of three PhD student programmers as a reference answer. Both accuracy and practical usefulness to programmers are explored, demonstrating that the authors' own SCOTCH method can be significantly more effective than existing techniques. Paper 3, ‘How developers perform feature location tasks: a human‐centric and process‐oriented exploratory study’, by Jinshui Wang, Xin Peng, Zhenchang Xing, and Wenyun Zhao, describes an empirical study of feature location in code by software developers. Feature location addresses the problem of identifying which parts of the source code of a system are concerned with implementing a specific business or technical concern. Automation in feature location has been a popular topic in the software maintenance research community for some time. In this paper, the authors choose instead to seek insight from how programmers actually perform the task in practice, concluding that the process can be understood at three levels of granularity, each of which is influenced by a number of external factors. The empirical insights reported here can be used to inform future work in supporting and automating this important aspect of software maintenance. We wish to thank the authors for having contributed to this special section, the ICSM 2011 Program Committee for their indications on which papers to include in the special section, and the journal referees, for their detailed and constructive comments, which greatly helped the authors to improve their papers.