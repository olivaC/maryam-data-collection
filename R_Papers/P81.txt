A brief tour of join point interfaces
In standard AspectJ, aspects and base code are often insufficiently decoupled, as aspects hold pointcuts, which can contain explicit textual references to base code. This hinders aspect evolution and reuse, and may hinder reasoning about aspects on the base-code side. In this demo we present join point interfaces as an extension to the aspect-oriented programming language AspectJ. Opposed to AspectJ, with join point interfaces aspects and base code communicate only through a shared interface abstraction. Aspects themselves go without pointcuts and only reference the interface. Pointcuts are typically defined on the base-code side, or not at all, as join point interfaces also support pure explicit invocation as known from publish-subscribe systems. As a result, users obtain a language which decouples aspects from base code using a modular type-checking algorithm, and which they can use to adopt aspects gradually as they desire.One major undertaking in the design of join point interfaces was to make the language as flexible to use as standard AspectJ, while nevertheless providing interfaces supported by strong type checks that can completely avoid type errors at composition time. In this demo we will discuss this inherent trade-off, we will present JPIs as an extension to the AspectBench Compiler, and will show how the language eases the maintenance of existing AspectJ applications.