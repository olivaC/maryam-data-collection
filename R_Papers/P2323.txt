Detecting data races with java pathfinder
Roughly speaking, a (data) race on a shared variable arises in a concurrent program if two threads access that variable simultaneously and the accesses are conflicting, that is, at least one of them writes to the variable. Although some races are benign, races often are an indication of bugs. Hence, tools that detect them are invaluable to those writing concurrent programs. Many tools have been developed to detect races. These tools are based on two types of race detection techniques: dynamic and static. In dynamic race detection, a single execution of a concurrent program is checked for races. One of the key approaches to detect races dynamically is based on locksets and has been popularized by the Eraser tool [1]. In this paper, we focus on static race detection. All potential executions are considered in static race detection. Although this approach gives rise to tools that are usually sound (that is, the races that are reported by the tool are real races), the tools are generally not complete (that is, not all races are always reported). Several different approaches exist to statically detect races. Here, we concentrate on model checking. In [2] model checking is exploited to detect races in programs written in an extension of C. Here, we focus on Java PathFinder (JPF)3 [3]. This is a model checker for Java bytecode. It has been developed in such a way that it can easily be extended. Extensions to detect races is the topic of this paper. The lockset algorithm and its numerous variations are usually exploited for dynamic race detection. However, this algorithm has also been used for static race detection. A variation on the lockset algorithm has been implemented in JPF.4 In this paper, we propose a different way to use JPF to detect races