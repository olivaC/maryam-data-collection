Code quality from the programmer's perspective
Quality in general and software quality in particular can be defined in several different ways, but any definition is relative to some person, who represents the target of the delivered quality. Quality is value for some person, rather than absolute value. This is especially true for software quality, where we can identify at least two categories of stakeholders for which quality is a central issue: users and developers. For users, software quality means ease of use, no crash at run-time, compliance with the requirements, correctness, etc. For developers, it means good design, encapsulation of functionalities, proper modularization, meaningful identifier names, documented interfaces, etc. These two views of the software quality are usually called external quality and internal quality of the software. Both are important and usually the assumption is made that the two are strongly related, so that it makes sense to invest in the improvement of both to eventually deliver a high quality product to the final user. For example, a good design may facilitate smooth adaptation of the software to a changed requirement or addition of new functionalities. A bad design may not prevent it, but may result in a system that contains more problems, due to the difficulty of evolving it, eventually delivering a lower quality (e.g., more bugs) to the user. The external, user’s, view on the quality is focused on “what” the software does, regardless of how it is implemented, but clearly the “how” is strictly connected with the (quality of) the “what”, in terms of correct and compliant implementation, ease of evolution and misbehaviors (e.g., crashes) exhibited over time. While internal and external quality are both a key issue in a software project, different contexts demand for a different emphasis. Let us consider a commercial, closed source (industrial) context, compared to a free, open source one. In an industrial context, the customer decides the fortune of the software. However, the customer’s needs and domain are only partially known by the developers. Hence, the risk of not matching the requirements accurately and correctly is probably the most important one. This justifies the large investment in system and acceptance testing, addressing the external quality view, that is typical of these organizations. Improvement of the internal code structure is considered of less importance and often there is no remaining time or resources for it. The open source context represents the other extreme of a continuum. Often, open source projects deal with the development of tools that are used by programmers or computer scientists, so domain and requirements are perfectly known and the risk of a requirement mismatch is relatively low. On the other hand, many developers, distributed world-wide, are often involved. This means that the design of the software is the key factor that decides its fortune, together with internal quality attributes, such as the understandability of the code and its capability of self-documentation. We have been involved in the assessment and improvement of the quality of the code developed for the ALICE experiment at CERN since 1999. In our experience, this context has several similarities with the open source context. Developers of the software are also the users, and the domain is perfectly known. Many contributors are spread across many countries. The code is subject to a large amount of changes and evolution over time, which demands for a good internal structure and for an easy way to understand the internal functionalities. In this paper, we first give an overview of the traditional way to address the internal software quality problem, which is the main quality concern for ALICE. Then, we report the results obtained so far, thanks to a tool for the enforcement of coding conventions and for the detection of bad programming practices. Finally we consider one dimension not covered by any existing approach to the internal code quality: the quality of the lexicon used by programmers, which deeply affects code understandability and maintainability. We report some preliminary results obtained from a few empirical studies conducted on the ALICE code. We conclude the paper with the research directions that we consider most promising in trying to address this quality dimension – the programmer’s lexicon.